import os
import json
import pandas as pd
import re
from typing import List, Dict, Tuple, Optional
from collections import defaultdict

def load_config_from_file(config_file: str) -> Dict:
    try:
        with open(config_file, 'r') as f:
            return json.load(f)
    except Exception as e:
        print(f"Error loading config file: {e}")
        return {}

class DatabricksSchemaGenerator:
    def __init__(self,
                 excel_file_path: str,
                 output_base_folder: str = "generated_schemas",
                 sheet_name: Optional[str] = None,
                 categories: Optional[Dict[str, Dict[str, str]]] = None):
        self.excel_file_path = excel_file_path
        self.output_base_folder = output_base_folder
        self.sheet_name = sheet_name
        self.categories_config = categories or {}
        self.tables_created = 0

    def map_datatype(self, datatype: str) -> str:
        if pd.isna(datatype):
            return 'VARCHAR(255)'
        dtype = str(datatype).upper().strip()

        if m := re.match(r'VARCHAR2\((\d+)\s*BYTE\)', dtype):
            return f'VARCHAR({m.group(1)})'
        if m := re.match(r'VARCHAR2\((\d+)\)', dtype):
            return f'VARCHAR({m.group(1)})'
        if m := re.match(r'NUMBER\((\d+),\s*(\d+)\)', dtype):
            return f'DECIMAL({m.group(1)},{m.group(2)})'
        if m := re.match(r'NUMBER\((\d+)\)', dtype):
            return 'INT' if int(m.group(1)) <= 10 else 'BIGINT'
        if 'TIMESTAMP' in dtype:
            return 'TIMESTAMP'
        if 'DATE' in dtype:
            return 'DATE'
        if 'CHAR' in dtype:
            return 'VARCHAR(1)'
        if 'CLOB' in dtype:
            return 'STRING'
        if 'BLOB' in dtype:
            return 'BINARY'
        return 'VARCHAR(255)'

    def load_excel_data(self) -> pd.DataFrame:
        try:
            df = pd.read_excel(self.excel_file_path, sheet_name=self.sheet_name)
            df = df.ffill()  # Forward-fill missing schema/table names
            # Drop rows where any schema column is 'NA'
            for cfg in self.categories_config.values():
                schema_col = cfg.get("schema_col")
                if schema_col and schema_col in df.columns:
                    df = df[df[schema_col].astype(str).str.upper() != "NA"]
            return df
        except Exception as e:
            print(f"Error loading Excel file: {e}")
            return pd.DataFrame()

    def extract_tables(self, df: pd.DataFrame) -> Dict[str, Dict[Tuple[str, str], List[Tuple[str, str]]]]:
        result = {}
        for cat, cfg in self.categories_config.items():
            schema_col = cfg.get('schema_col')
            table_col = cfg.get('table_col')
            column_col = cfg.get('column_col')
            datatype_col = cfg.get('datatype_col', '')

            tables = defaultdict(list)
            seen = defaultdict(set)

            for _, row in df.iterrows():
                schema = str(row.get(schema_col, '')).strip() or 'default_schema'
                table = str(row.get(table_col, '')).strip()
                column = str(row.get(column_col, '')).strip()
                dtype_val = row.get(datatype_col, '') if datatype_col else ''

                if table and column and column.lower() not in seen[(schema, table)]:
                    dtype = self.map_datatype(dtype_val) if dtype_val else 'VARCHAR(255)'
                    tables[(schema, table)].append((column, dtype))
                    seen[(schema, table)].add(column.lower())

            result[cat] = tables
        return result

    def generate_schema_sql(self, schema: str, table: str, columns: List[Tuple[str, str]], category: str) -> str:
        sql = f"-- {category} - {table} Table Schema\n"
        sql += f"CREATE TABLE IF NOT EXISTS external_catalog.{schema}.{table} (\n"
        sql += ",\n".join([f"    [{col}] {dtype}" for col, dtype in columns])
        sql += "\n);"
        return sql

    def create_folder_structure(self):
        folders = list(self.categories_config.keys()) + ["consolidated"]
        os.makedirs(self.output_base_folder, exist_ok=True)
        for folder in folders:
            os.makedirs(os.path.join(self.output_base_folder, folder), exist_ok=True)

    def generate_category_consolidated_schema(self, category: str, tables: Dict[Tuple[str, str], List[Tuple[str, str]]]) -> str:
        sql = f"-- {category} CATEGORY - CONSOLIDATED SCHEMA\n\n"
        count = 0
        for (schema, table), cols in tables.items():
            if cols:
                sql += self.generate_schema_sql(schema, table, cols, category) + "\n\n"
                count += 1
        sql += f"-- Total tables in {category} consolidated schema: {count}\n"
        return sql, count

    def generate_master_consolidated_schema(self, all_tables: Dict[str, Dict[Tuple[str, str], List[Tuple[str, str]]]]) -> str:
        sql = "-- MASTER CONSOLIDATED SCHEMA\n\n"
        total = 0
        for cat, tables in all_tables.items():
            sql += f"-- {cat} CATEGORY\n\n"
            for (schema, table), cols in tables.items():
                if cols:
                    sql += self.generate_schema_sql(schema, table, cols, cat) + "\n\n"
                    total += 1
        sql += f"-- Total tables in master consolidated schema: {total}\n"
        return sql

    def run(self):
        df = self.load_excel_data()
        if df.empty:
            print("No data loaded.")
            return

        self.create_folder_structure()
        all_tables = self.extract_tables(df)
        total_tables = 0

        for cat, tables in all_tables.items():
            folder = os.path.join(self.output_base_folder, cat)
            count = 0
            for (schema, table), cols in tables.items():
                if cols:
                    sql = self.generate_schema_sql(schema, table, cols, cat)
                    with open(os.path.join(folder, f"{table.lower()}.sql"), "w") as f:
                        f.write(sql)
                    count += 1
            consolidated_sql, cat_count = self.generate_category_consolidated_schema(cat, tables)
            with open(os.path.join(folder, f"{cat.lower()}_consolidated_{cat_count}.sql"), "w") as f:
                f.write(consolidated_sql)
            total_tables += count

        master_sql = self.generate_master_consolidated_schema(all_tables)
        with open(os.path.join(self.output_base_folder, "consolidated", "all_tables_master_consolidated.sql"), "w") as f:
            f.write(master_sql)

        print(f"Total tables created: {total_tables}")
