{
  "azure_openai": {
    "api_version": "2023-12-01-preview",
    "default": {
      "api_key": "your-default-api-key",
      "azure_endpoint": "https://your-default-endpoint.openai.azure.com/",
      "deployment_name": "your-default-deployment-name"
    },
    "models": {
      "invoice": {
        "api_key": "your-invoice-api-key",
        "azure_endpoint": "https://your-invoice-endpoint.openai.azure.com/",
        "deployment_name": "gpt-4-vision-invoice"
      },
      "eob": {
        "api_key": "your-eob-api-key", 
        "azure_endpoint": "https://your-eob-endpoint.openai.azure.com/",
        "deployment_name": "gpt-4-vision-eob"
      },
      "claim": {
        "api_key": "your-claim-api-key",
        "azure_endpoint": "https://your-claim-endpoint.openai.azure.com/",
        "deployment_name": "gpt-4-vision-claim"
      }
    }
  },
  "azure_storage": {
    "connection_string": "your-connection-string",
    "input_container": "input-pdfs",
    "output_container": "processed-results",
    "input_archive_container": "archived-inputs",
    "high_confidence_folder": "high_confidence/",
    "low_confidence_folder": "low_confidence/"
  },
  "processing": {
    "batch_size": 10,
    "confidence_threshold": 80,
    "zoom_factor": 2.0,
    "timeout_seconds": 300,
    "document_types": {
      "invoice": {
        "extraction_fields": ["invoice_number", "total_amount", "date", "vendor"],
        "prompt_module": "invoice_prompt"
      },
      "eob": {
        "extraction_fields": ["eob_number", "patient_name", "service_date", "paid_amount", "provider"],
        "prompt_module": "eob_prompt"
      },
      "claim": {
        "extraction_fields": ["claim_number", "patient_id", "diagnosis_code", "procedure_code", "claim_amount"],
        "prompt_module": "claim_prompt",
        "overlay_settings": {
          "enabled": true,
          "overlay_template_path": "claim_overlay_template.pdf",
          "content_threshold_percent": 5.0,
          "overlay_dpi": 300
        }
      }
    }
  },
  "archive": {
    "blob_input_move_on": true,
    "archive_name_format": "archive_{timestamp}.zip",
    "processed_folder": "processed/",
    "unprocessed_folder": "unprocessed/"
  }
}

--------------

  import fitz  # PyMuPDF
import cv2
import numpy as np
from PIL import Image
import os
import logging
from io import BytesIO


class OverlayProcessor:
    def __init__(self, config, logger=None):
        self.config = config
        self.logger = logger or logging.getLogger("overlay_processor")
    
    def pdf_to_image(self, pdf_data, width=None, height=None, dpi=300, page_num=0):
        """
        Convert a specific page of PDF to image.
        
        Args:
            pdf_data: PDF data as bytes
            width: Target width (optional)
            height: Target height (optional)
            dpi: DPI for conversion
            page_num: Page number to convert (0-based)
        
        Returns:
            numpy array: Image data
        """
        try:
            doc = fitz.open("pdf", pdf_data)
            if len(doc) <= page_num:
                raise ValueError(f"Page {page_num} not found in PDF (total pages: {len(doc)})")

            page = doc.load_page(page_num)
            pix = page.get_pixmap(dpi=dpi)

            img = np.frombuffer(pix.samples, dtype=np.uint8).reshape(pix.height, pix.width, pix.n)
            if pix.n == 4:
                img = cv2.cvtColor(img, cv2.COLOR_BGRA2BGR)

            # Resize if width/height specified
            if width and height:
                img = cv2.resize(img, (width, height))

            doc.close()
            return img
        
        except Exception as e:
            self.logger.error(f"Error converting PDF to image: {str(e)}")
            return None
    
    def calculate_content_percentage(self, img):
        """
        Calculate the percentage of non-white content in the image.
        
        Args:
            img: Image as numpy array
        
        Returns:
            float: Percentage of non-white content
        """
        try:
            gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
            
            # Threshold to identify non-white pixels (adjust threshold as needed)
            # Values less than 240 are considered non-white content
            _, binary = cv2.threshold(gray, 240, 255, cv2.THRESH_BINARY_INV)
            
            # Calculate percentage of non-white pixels
            total_pixels = img.shape[0] * img.shape[1]
            content_pixels = np.count_nonzero(binary)
            content_percentage = (content_pixels / total_pixels) * 100
            
            return content_percentage
        
        except Exception as e:
            self.logger.error(f"Error calculating content percentage: {str(e)}")
            return 100.0  # Return high percentage to avoid overlay on error
    
    def remove_white_background(self, img):
        """
        Remove white background (make it transparent).
        
        Args:
            img: Input image as numpy array
        
        Returns:
            numpy array: Image with alpha channel
        """
        try:
            gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
            _, alpha = cv2.threshold(gray, 240, 255, cv2.THRESH_BINARY_INV)
            b, g, r = cv2.split(img)
            rgba = cv2.merge([b, g, r, alpha])
            return rgba
        
        except Exception as e:
            self.logger.error(f"Error removing white background: {str(e)}")
            return None
    
    def overlay_transparent(self, background, overlay_rgba):
        """
        Overlay transparent image onto background.
        
        Args:
            background: Background image
            overlay_rgba: Overlay image with alpha channel
        
        Returns:
            numpy array: Blended image
        """
        try:
            overlay_rgb = overlay_rgba[:, :, :3]
            alpha = overlay_rgba[:, :, 3] / 255.0
            alpha = np.stack([alpha] * 3, axis=-1)

            blended = (overlay_rgb * alpha + background * (1 - alpha)).astype(np.uint8)
            return blended
        
        except Exception as e:
            self.logger.error(f"Error overlaying images: {str(e)}")
            return background
    
    def needs_overlay(self, img, threshold_percent):
        """
        Check if image needs overlay based on content percentage.
        
        Args:
            img: Input image
            threshold_percent: Threshold percentage for content
        
        Returns:
            tuple: (needs_overlay: bool, content_percentage: float)
        """
        content_percentage = self.calculate_content_percentage(img)
        needs_overlay = content_percentage < threshold_percent
        
        return needs_overlay, content_percentage
    
    def process_single_page_overlay(self, original_page_data, overlay_template_data, page_num, overlay_settings):
        """
        Process overlay for a single page.
        
        Args:
            original_page_data: Original PDF page data
            overlay_template_data: Overlay template PDF data
            page_num: Page number being processed
            overlay_settings: Overlay configuration settings
        
        Returns:
            tuple: (processed_image_bytes, overlay_applied, content_percentage)
        """
        try:
            dpi = overlay_settings.get("overlay_dpi", 300)
            threshold_percent = overlay_settings.get("content_threshold_percent", 5.0)
            
            # Convert original page to image
            original_img = self.pdf_to_image(original_page_data, dpi=dpi, page_num=0)
            if original_img is None:
                self.logger.error(f"Failed to convert original page {page_num} to image")
                return None, False, 0.0
            
            # Check if overlay is needed
            needs_overlay, content_percentage = self.needs_overlay(original_img, threshold_percent)
            
            self.logger.info(f"Page {page_num + 1}: Content percentage = {content_percentage:.2f}%, "
                           f"Needs overlay = {needs_overlay} (threshold = {threshold_percent}%)")
            
            if not needs_overlay:
                # Return original image as PDF bytes
                pil_img = Image.fromarray(cv2.cvtColor(original_img, cv2.COLOR_BGR2RGB))
                img_bytes = BytesIO()
                pil_img.save(img_bytes, format='PDF', resolution=float(dpi))
                return img_bytes.getvalue(), False, content_percentage
            
            # Get dimensions from original
            h, w = original_img.shape[:2]
            
            # Convert overlay template to same size
            overlay_img = self.pdf_to_image(overlay_template_data, width=w, height=h, dpi=dpi, page_num=0)
            if overlay_img is None:
                self.logger.error("Failed to convert overlay template to image")
                # Return original image
                pil_img = Image.fromarray(cv2.cvtColor(original_img, cv2.COLOR_BGR2RGB))
                img_bytes = BytesIO()
                pil_img.save(img_bytes, format='PDF', resolution=float(dpi))
                return img_bytes.getvalue(), False, content_percentage
            
            # Apply overlay
            overlay_rgba = self.remove_white_background(overlay_img)
            if overlay_rgba is None:
                self.logger.error("Failed to process overlay transparency")
                pil_img = Image.fromarray(cv2.cvtColor(original_img, cv2.COLOR_BGR2RGB))
                img_bytes = BytesIO()
                pil_img.save(img_bytes, format='PDF', resolution=float(dpi))
                return img_bytes.getvalue(), False, content_percentage
            
            final_img = self.overlay_transparent(original_img, overlay_rgba)
            
            # Convert back to PDF bytes
            pil_img = Image.fromarray(cv2.cvtColor(final_img, cv2.COLOR_BGR2RGB))
            img_bytes = BytesIO()
            pil_img.save(img_bytes, format='PDF', resolution=float(dpi))
            
            self.logger.info(f"Successfully applied overlay to page {page_num + 1}")
            return img_bytes.getvalue(), True, content_percentage
        
        except Exception as e:
            self.logger.error(f"Error processing overlay for page {page_num}: {str(e)}")
            return None, False, 0.0
    
    def process_multipage_overlay(self, original_pdf_data, overlay_template_path, overlay_settings):
        """
        Process overlay for multi-page PDF.
        
        Args:
            original_pdf_data: Original PDF data as bytes
            overlay_template_path: Path to overlay template PDF
            overlay_settings: Overlay configuration settings
        
        Returns:
            tuple: (processed_pdf_bytes, overlay_stats)
        """
        try:
            # Load overlay template
            if not os.path.exists(overlay_template_path):
                self.logger.error(f"Overlay template not found: {overlay_template_path}")
                return original_pdf_data, {"error": "Template not found"}
            
            with open(overlay_template_path, 'rb') as f:
                overlay_template_data = f.read()
            
            # Get number of pages in original PDF
            doc = fitz.open("pdf", original_pdf_data)
            num_pages = len(doc)
            doc.close()
            
            self.logger.info(f"Processing {num_pages} pages for overlay")
            
            processed_pages = []
            overlay_stats = {
                "total_pages": num_pages,
                "pages_with_overlay": 0,
                "pages_without_overlay": 0,
                "content_percentages": [],
                "errors": []
            }
            
            # Process each page
            for page_num in range(num_pages):
                # Extract single page
                page_doc = fitz.open("pdf", original_pdf_data)
                single_page_doc = fitz.open()
                single_page_doc.insert_pdf(page_doc, from_page=page_num, to_page=page_num)
                
                page_bytes = single_page_doc.tobytes()
                page_doc.close()
                single_page_doc.close()
                
                # Process overlay for this page
                processed_page, overlay_applied, content_percentage = self.process_single_page_overlay(
                    page_bytes, overlay_template_data, page_num, overlay_settings
                )
                
                if processed_page:
                    processed_pages.append(processed_page)
                    overlay_stats["content_percentages"].append(content_percentage)
                    
                    if overlay_applied:
                        overlay_stats["pages_with_overlay"] += 1
                    else:
                        overlay_stats["pages_without_overlay"] += 1
                else:
                    self.logger.error(f"Failed to process page {page_num + 1}")
                    overlay_stats["errors"].append(f"Failed to process page {page_num + 1}")
                    # Add original page
                    processed_pages.append(page_bytes)
                    overlay_stats["pages_without_overlay"] += 1
            
            # Combine all processed pages into single PDF
            final_doc = fitz.open()
            for page_bytes in processed_pages:
                temp_doc = fitz.open("pdf", page_bytes)
                final_doc.insert_pdf(temp_doc)
                temp_doc.close()
            
            final_pdf_bytes = final_doc.tobytes()
            final_doc.close()
            
            self.logger.info(f"Overlay processing complete: "
                           f"{overlay_stats['pages_with_overlay']} pages with overlay, "
                           f"{overlay_stats['pages_without_overlay']} pages without overlay")
            
            return final_pdf_bytes, overlay_stats
        
        except Exception as e:
            self.logger.error(f"Error in multi-page overlay processing: {str(e)}")
            return original_pdf_data, {"error": str(e)}

-------
  # Update your main() function argument parser

def main():
    parser = argparse.ArgumentParser(description="Process PDF files using Azure OpenAI with document type and overlay support")
    parser.add_argument("--apitype", choices=["general", "batch"], required=True, 
                      help="API type to use (general or batch)")
    parser.add_argument("--source", choices=["azure", "local"], required=True,
                      help="Source location of PDF files (azure or local)")
    parser.add_argument("--folder", required=True, 
                      help="Folder path (in Azure Blob Storage or local filesystem)")
    parser.add_argument("--doctype", choices=["invoice", "eob", "claim"], required=True,
                      help="Document type to process (invoice, eob, or claim)")
    parser.add_argument("--config", default="config.json", 
                      help="Path to configuration file")
    parser.add_argument("--log-level", choices=["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"],
                     default="INFO", help="Set the logging level")
    parser.add_argument("--no-archive", action="store_true",
                     help="Disable archiving regardless of config setting")
    # NEW: Add overlay control parameter
    parser.add_argument("--claim-overlay", action="store_true",
                     help="Enable overlay processing for claim documents (only works with --doctype claim)")
    
    args = parser.parse_args()
    
    # Validate overlay parameter
    if args.claim_overlay and args.doctype != "claim":
        raise ValueError("--claim-overlay can only be used with --doctype claim")
    
    # ... rest of main function ...


  -----
  # Add this import at the top of your main script
from overlay_processor import OverlayProcessor

def process_azure_pdf_files(config, api_type, azure_folder, doc_type, enable_overlay, logger):
    """
    Process PDF files from Azure Blob Storage with archiving and overlay support.
    
    Parameters:
    - config: Configuration dictionary
    - api_type: 'batch' or 'general'
    - azure_folder: Folder path in Azure Blob Storage
    - doc_type: Document type ('invoice', 'eob', 'claim')
    - enable_overlay: Boolean to enable overlay processing (only for claims)
    - logger: Logger instance
    """
    # Get document-specific configuration including model config
    extraction_fields, systemprompt, prompt_template, model_config = get_document_config(config, doc_type)
    logger.info(f"Processing {doc_type} documents with fields: {extraction_fields}")
    logger.info(f"Using prompt module: {config['processing']['document_types'][doc_type]['prompt_module']}")
    
    # Check overlay settings
    overlay_enabled = False
    overlay_processor = None
    overlay_settings = None
    
    if doc_type == "claim" and enable_overlay:
        doc_config = config["processing"]["document_types"][doc_type]
        overlay_settings = doc_config.get("overlay_settings", {})
        
        if overlay_settings.get("enabled", False):
            overlay_enabled = True
            overlay_processor = OverlayProcessor(config, logger)
            logger.info("Overlay processing ENABLED for claim documents")
            logger.info(f"  Template path: {overlay_settings.get('overlay_template_path')}")
            logger.info(f"  Content threshold: {overlay_settings.get('content_threshold_percent', 5.0)}%")
        else:
            logger.info("Overlay processing DISABLED in configuration")
    else:
        logger.info("Overlay processing not applicable for this document type")
    
    # ... existing initialization code ...
    
    # Process each PDF
    for i, blob_name in enumerate(pdf_blobs):
        file_processed_successfully = False
        
        try:
            logger.info(f"Processing file {i+1}/{len(pdf_blobs)}: {blob_name}")
            
            # Download blob to memory
            logger.debug(f"Downloading blob: {blob_name}")
            blob_content = storage_helper.download_blob_to_memory(blob_name)
            
            if blob_content is None:
                logger.error(f"Could not download blob: {blob_name}")
                unprocessed_files.append(blob_name)
                continue
            
            # OVERLAY PROCESSING (if enabled)
            processed_pdf_content = blob_content
            overlay_stats = None
            
            if overlay_enabled and overlay_processor:
                logger.info(f"Applying overlay processing to {filename}")
                overlay_template_path = overlay_settings.get("overlay_template_path")
                
                processed_pdf_content, overlay_stats = overlay_processor.process_multipage_overlay(
                    blob_content, overlay_template_path, overlay_settings
                )
                
                if overlay_stats:
                    logger.info(f"Overlay stats for {filename}:")
                    logger.info(f"  Total pages: {overlay_stats.get('total_pages', 0)}")
                    logger.info(f"  Pages with overlay: {overlay_stats.get('pages_with_overlay', 0)}")
                    logger.info(f"  Pages without overlay: {overlay_stats.get('pages_without_overlay', 0)}")
                    logger.info(f"  Average content percentage: {np.mean(overlay_stats.get('content_percentages', [0])):.2f}%")
                    
                    if overlay_stats.get('errors'):
                        logger.warning(f"  Overlay errors: {len(overlay_stats['errors'])}")
                        for error in overlay_stats['errors']:
                            logger.warning(f"    {error}")
            
            # Extract pages as base64 strings (use processed content)
            filename = blob_name.split('/')[-1]
            logger.info(f"Extracting pages from {filename}")
            pages = pdf_processor.extract_pdf_pages(processed_pdf_content)  # Use processed content
            
            if not pages:
                logger.warning(f"No pages extracted from {filename}")
                unprocessed_files.append(blob_name)
                continue
            
            logger.info(f"Extracted {len(pages)} pages from {filename}")
            
            # ... rest of processing logic remains the same ...
            
            # When uploading source PDF, use processed content if overlay was applied
            source_folder = f"source_documents/{doc_type}/" + folder_path
            source_blob_name = f"{source_folder}{filename}"
            
            # Add overlay suffix to filename if overlay was applied
            if overlay_enabled and overlay_stats and overlay_stats.get('pages_with_overlay', 0) > 0:
                base_name, ext = os.path.splitext(source_blob_name)
                source_blob_name = f"{base_name}_overlayed{ext}"
            
            logger.info(f"Uploading source PDF to {source_blob_name}")
            source_success, source_url = storage_helper.upload_to_storage(
                source_blob_name,
                processed_pdf_content,  # Use processed content
                "application/pdf"
            )
            
            # ... rest of the function remains the same ...

  ------
  # In your main() function, find this line:
# process_azure_pdf_files(config, args.apitype, args.folder, args.doctype, logger)

# Replace with:
process_azure_pdf_files(config, args.apitype, args.folder, args.doctype, args.claim_overlay, logger)

  ------
  import fitz  # PyMuPDF

def get_page_content_ratio(pdf_path, page_num=0):
    # Open the PDF
    doc = fitz.open(pdf_path)
    page = doc[page_num]

    # Get page dimensions
    rect = page.rect
    page_area = rect.width * rect.height

    # Extract text blocks (with bounding boxes)
    blocks = page.get_text("blocks")  # list of [x0, y0, x1, y1, text, block_no, block_type]
    
    content_area = 0
    for b in blocks:
        x0, y0, x1, y1 = b[:4]
        content_area += (x1 - x0) * (y1 - y0)

    # Extract images and include their area
    for img in page.get_images(full=True):
        xref = img[0]
        bbox = page.get_image_bbox(img)
        content_area += bbox.width * bbox.height

    ratio = (content_area / page_area) * 100
    return ratio

# Example usage
pdf_path = "sample.pdf"
print("Content ratio (Page 1):", get_page_content_ratio(pdf_path, 0), "%")


  
