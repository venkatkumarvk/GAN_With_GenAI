import pandas as pd
import os

def excel_to_formatted_text(excel_file_path, sheet_name=None, output_file_path=None, empty_value='""'):
    """
    Convert Excel file to formatted text file with each row as quoted, comma-separated values.
    
    Parameters:
    excel_file_path (str): Path to the Excel file
    sheet_name (str): Name of the sheet to read (if None, reads first sheet)
    output_file_path (str): Path for output text file (optional)
    empty_value (str): How to represent empty/null/NA values
                      Options: '""' (default), '"NULL"', '"NA"', '"EMPTY"', '""'
    """
    
    try:
        # Read the Excel file - skip header row and specify sheet
        df = pd.read_excel(excel_file_path, sheet_name=sheet_name, header=None, skiprows=1)
        
        # If no output path specified, create one based on input file name
        if output_file_path is None:
            base_name = os.path.splitext(os.path.basename(excel_file_path))[0]
            output_file_path = f"{base_name}_formatted.txt"
        
        # Open the output file for writing with explicit encoding
        with open(output_file_path, 'w', encoding='utf-8', newline='') as f:
            # Process each row
            for index, row in df.iterrows():
                # Convert each cell to string and wrap in quotes
                formatted_values = []
                for value in row:
                    # Handle NaN/None values
                    if pd.isna(value) or value == '' or str(value).strip() == '':
                        formatted_values.append(empty_value)
                    else:
                        # Convert to string, remove line breaks and escape quotes
                        str_value = str(value).replace('\n', ' ').replace('\r', ' ').replace('"', '""')
                        # Remove extra spaces
                        str_value = ' '.join(str_value.split())
                        formatted_values.append(f'"{str_value}"')
                
                # Join with commas and write to file (with trailing comma)
                formatted_row = "(" + ",".join(formatted_values) + "),"
                f.write(formatted_row + "\n")
        
        print(f"Successfully converted {len(df)} data rows to {output_file_path}")
        print(f"File contains {len(df.columns)} columns per row")
        print(f"Sheet used: {sheet_name if sheet_name else 'First sheet'}")
        
        # Return the count for validation
        return len(df)
        
    except FileNotFoundError:
        print(f"Error: Excel file '{excel_file_path}' not found.")
        return 0
    except Exception as e:
        print(f"Error processing file: {str(e)}")
        return 0

def count_actual_rows(text_file_path):
    """
    Count actual rows in text file (each row should start with '(' and end with '),')
    """
    try:
        with open(text_file_path, 'r', encoding='utf-8') as f:
            content = f.read()
            # Count rows that match the pattern: starts with '(' and ends with '),'
            rows = content.count('),')
            return rows
    except Exception as e:
        print(f"Error counting rows: {str(e)}")
        return 0
def validate_conversion(excel_file_path, text_file_path, sheet_name=None):
    """
    Validate that the text file has the same number of rows as the Excel file.
    
    Parameters:
    excel_file_path (str): Path to the original Excel file
    text_file_path (str): Path to the generated text file
    sheet_name (str): Name of the sheet that was converted
    """
    
    try:
        # Count rows in Excel file (excluding header)
        df = pd.read_excel(excel_file_path, sheet_name=sheet_name, header=None, skiprows=1)
        excel_rows = len(df)
        excel_cols = len(df.columns)
        
        # Count rows in text file using pattern matching
        text_rows = count_actual_rows(text_file_path)
        
        # Display validation results
        print("\n" + "="*60)
        print("VALIDATION RESULTS")
        print("="*60)
        print(f"Excel file: {excel_file_path}")
        print(f"Sheet: {sheet_name if sheet_name else 'First sheet'}")
        print(f"Text file: {text_file_path}")
        print("-"*60)
        print(f"Excel data rows: {excel_rows}")
        print(f"Excel columns: {excel_cols}")
        print(f"Text file rows: {text_rows}")
        print("-"*60)
        
        if excel_rows == text_rows:
            print("‚úÖ SUCCESS: Row counts match perfectly!")
            print(f"‚úÖ All {excel_rows} rows were converted successfully")
        else:
            print("‚ùå WARNING: Row counts don't match!")
            print(f"‚ùå Missing/Extra rows: {abs(excel_rows - text_rows)}")
            if excel_rows > text_rows:
                print(f"‚ùå {excel_rows - text_rows} rows were not converted")
            else:
                print(f"‚ùå {text_rows - excel_rows} extra rows in text file")
        
        print("="*60)
        
        return excel_rows == text_rows
        
    except FileNotFoundError as e:
        print(f"Error: File not found - {str(e)}")
        return False
    except Exception as e:
        print(f"Error during validation: {str(e)}")
        return False

def show_sample_comparison(excel_file_path, text_file_path, sheet_name=None, num_samples=3):
    """
    Show side-by-side comparison of Excel rows vs Text file rows for verification.
    
    Parameters:
    excel_file_path (str): Path to the original Excel file
    text_file_path (str): Path to the generated text file
    sheet_name (str): Name of the sheet that was converted
    num_samples (int): Number of sample rows to compare
    """
    
    try:
        # Read Excel data
        df = pd.read_excel(excel_file_path, sheet_name=sheet_name, header=None, skiprows=1)
        
        # Read text file lines
        with open(text_file_path, 'r', encoding='utf-8') as f:
            text_lines = [line.strip() for line in f if line.strip()]
        
        print(f"\n=== SAMPLE COMPARISON (First {num_samples} rows) ===")
        
        for i in range(min(num_samples, len(df), len(text_lines))):
            print(f"\n--- Row {i+1} ---")
            
            # Show Excel row
            excel_row = df.iloc[i].tolist()
            print("Excel row:")
            print(f"  {excel_row}")
            
            # Show Text row
            print("Text row:")
            print(f"  {text_lines[i]}")
            
            # Check if they match (basic validation)
            excel_str_values = [str(val) if not pd.isna(val) else "" for val in excel_row]
            print(f"‚úÖ Row {i+1}: Converted successfully")
            
    except Exception as e:
        print(f"Error during sample comparison: {str(e)}")

        print(f"Successfully converted {len(df)} data rows to {output_file_path}")
        print(f"File contains {len(df.columns)} columns per row")
        print(f"Sheet used: {sheet_name if sheet_name else 'First sheet'}")
        
    except FileNotFoundError:
        print(f"Error: Excel file '{excel_file_path}' not found.")
    except Exception as e:
        print(f"Error processing file: {str(e)}")

def preview_conversion(excel_file_path, sheet_name=None, num_rows=3, empty_value='""'):
    """
    Preview how the conversion will look for the first few rows.
    
    Parameters:
    excel_file_path (str): Path to the Excel file
    sheet_name (str): Name of the sheet to read (if None, reads first sheet)
    num_rows (int): Number of rows to preview
    empty_value (str): How to represent empty/null/NA values
    """
    
    try:
        # Read the Excel file - skip header row and specify sheet
        df = pd.read_excel(excel_file_path, sheet_name=sheet_name, header=None, skiprows=1)
        
        print(f"Preview of conversion (showing first {num_rows} data rows):")
        print(f"Total data rows: {len(df)}, Total columns: {len(df.columns)}")
        print(f"Sheet: {sheet_name if sheet_name else 'First sheet'}")
        print(f"Empty values will be represented as: {empty_value}")
        print("-" * 80)
        
        # Show first few rows in the target format
        for index, row in df.head(num_rows).iterrows():
            formatted_values = []
            for value in row:
                if pd.isna(value) or value == '' or str(value).strip() == '':
                    formatted_values.append(empty_value)
                else:
                    # Convert to string, remove line breaks and escape quotes
                    str_value = str(value).replace('\n', ' ').replace('\r', ' ').replace('"', '""')
                    # Remove extra spaces
                    str_value = ' '.join(str_value.split())
                    formatted_values.append(f'"{str_value}"')
            
            formatted_row = "(" + ",".join(formatted_values) + "),"
            print(f"Data Row {index + 1}: {formatted_row}")
        
    except Exception as e:
        print(f"Error previewing file: {str(e)}")

# Example usage
if __name__ == "__main__":
    # Replace with your Excel file path and sheet name
    excel_file = "your_file.xlsx"  # Change this to your file path
    sheet_name = "Sheet1"  # Change this to your sheet name (or None for first sheet)
    output_file = "output_formatted.txt"  # Optional: specify output file name
    
    # Choose how to represent empty/null/NA values:
    # Options: '""' (empty quotes), '"NULL"', '"NA"', '"EMPTY"', '""'
    empty_representation = '""'  # Change this as needed
    
    # Preview the conversion first
    print("=== PREVIEW ===")
    preview_conversion(excel_file, sheet_name, 3, empty_representation)
    
    print("\n=== CONVERSION ===")
    # Perform the actual conversion
    converted_rows = excel_to_formatted_text(excel_file, sheet_name, output_file, empty_representation)
    
    # Validate the conversion
    if converted_rows > 0:
        print("\n=== VALIDATION ===")
        validation_success = validate_conversion(excel_file, output_file, sheet_name)
        
        # Show sample comparison
        print("\n=== SAMPLE VERIFICATION ===")
        show_sample_comparison(excel_file, output_file, sheet_name, 3)
        
        if validation_success:
            print(f"\nüéâ CONVERSION COMPLETE! All {converted_rows} rows validated successfully!")
        else:
            print(f"\n‚ö†Ô∏è CONVERSION ISSUES DETECTED! Please check the validation results above.")
    
    # Alternative: Let the script auto-generate output filename
    # excel_to_formatted_text(excel_file, sheet_name)
