import os
import sys
import base64
import json
from pathlib import Path
from openai import AzureOpenAI
import fitz  # PyMuPDF
import io
import logging
import traceback

# Logging Setup
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s: %(message)s',
    handlers=[
        logging.FileHandler('pdf_classification_log.txt'),
        logging.StreamHandler(sys.stdout)
    ]
)

# Azure OpenAI Configuration
try:
    client = AzureOpenAI(
        azure_endpoint=os.environ.get("AZURE_OPENAI_ENDPOINT"),
        api_key=os.environ.get("AZURE_OPENAI_API_KEY"),
        api_version="2024-02-15-preview"
    )
    logging.info("Azure OpenAI Client initialized successfully")
except Exception as e:
    logging.error(f"Failed to initialize Azure OpenAI Client: {e}")
    sys.exit(1)

# Deployment Configuration
DEPLOYMENT_NAME = os.environ.get("AZURE_OPENAI_DEPLOYMENT", "gpt-4o")

def convert_pdf_to_images(pdf_path, dpi=300):
    """
    Convert PDF pages to images using PyMuPDF
    
    Args:
        pdf_path (str): Path to the PDF file
        dpi (int): Dots per inch for image conversion
    
    Returns:
        list: List of image paths
    """
    image_paths = []
    try:
        # Open the PDF
        doc = fitz.open(pdf_path)
        
        # Create a temporary directory for images
        os.makedirs('temp_pdf_images', exist_ok=True)
        
        # Convert each page
        for page_num in range(len(doc)):
            page = doc[page_num]
            
            # Render page to an image
            pix = page.get_pixmap(dpi=dpi)
            
            # Save image
            image_path = f'temp_pdf_images/page_{page_num + 1}.png'
            pix.save(image_path)
            image_paths.append(image_path)
        
        doc.close()
        logging.info(f"Converted {len(image_paths)} pages from {pdf_path}")
        return image_paths
    
    except Exception as e:
        logging.error(f"Error converting PDF to images: {e}")
        traceback.print_exc()
        return []

def encode_image_to_base64(image_path):
    """
    Encode an image to base64 with comprehensive error handling
    """
    try:
        with open(image_path, "rb") as image_file:
            base64_image = base64.b64encode(image_file.read()).decode('utf-8')
            logging.info(f"Image {image_path} encoded successfully. Size: {len(base64_image)} characters")
            return base64_image
    except Exception as e:
        logging.error(f"Error encoding image {image_path}: {e}")
        traceback.print_exc()
        raise

def classify_document_page(base64_image, page_num):
    """
    Classify a single document page using Azure OpenAI GPT-4o vision model
    """
    try:
        messages = [
            {
                "role": "system",
                "content": "You are an expert document classifier. Analyze the document page and classify it precisely."
            },
            {
                "role": "user",
                "content": [
                    {
                        "type": "text",
                        "text": f"Analyze page {page_num} of this document. "
                                "Respond ONLY with a JSON object containing: "
                                "- 'type': document type (string) "
                                "- 'confidence': certainty percentage (0-100) "
                                "- 'reasoning': brief explanation of classification "
                                "- 'page_number': the page number being classified"
                    },
                    {
                        "type": "image",
                        "image": {
                            "base64": base64_image
                        }
                    }
                ]
            }
        ]

        # Call Azure OpenAI with vision input
        response = client.chat.completions.create(
            model=DEPLOYMENT_NAME,
            messages=messages,
            max_tokens=300,
            temperature=0.1
        )

        # Extract response
        response_text = response.choices[0].message.content.strip()
        logging.info(f"Raw Response for Page {page_num}: {response_text}")

        # Parse JSON response
        try:
            classification = json.loads(response_text)
            classification['page_number'] = page_num
            logging.info(f"Classification Result for Page {page_num}: {classification}")
            return classification
        except json.JSONDecodeError:
            logging.error(f"JSON Parsing Error on Page {page_num}. Response: {response_text}")
            return {
                "type": "unclassified",
                "confidence": 0,
                "reasoning": f"Failed to parse JSON. Raw response: {response_text}",
                "page_number": page_num
            }

    except Exception as e:
        logging.error(f"Classification Error on Page {page_num}: {e}")
        traceback.print_exc()
        return {
            "type": "error",
            "confidence": 0,
            "reasoning": str(e),
            "page_number": page_num
        }

def process_pdf(pdf_path):
    """
    Process a multi-page PDF for classification
    """
    try:
        # Convert PDF to images
        image_paths = convert_pdf_to_images(pdf_path)
        
        if not image_paths:
            logging.error(f"No images generated from PDF: {pdf_path}")
            return []
        
        # Classify each page
        classifications = []
        for idx, image_path in enumerate(image_paths, 1):
            try:
                # Encode image
                base64_image = encode_image_to_base64(image_path)
                
                # Classify page
                page_classification = classify_document_page(base64_image, idx)
                classifications.append(page_classification)
            
            except Exception as e:
                logging.error(f"Error processing page {idx}: {e}")
                classifications.append({
                    "type": "error",
                    "confidence": 0,
                    "reasoning": str(e),
                    "page_number": idx
                })
        
        return classifications
    
    finally:
        # Clean up temporary images
        try:
            import shutil
            shutil.rmtree('temp_pdf_images', ignore_errors=True)
        except Exception as e:
            logging.warning(f"Error cleaning up temporary images: {e}")

def main():
    # Input and output directories
    input_dir = "input_pdfs"
    output_dir = "classification_results"
    
    # Validate environment setup
    if not os.environ.get("AZURE_OPENAI_ENDPOINT"):
        logging.error("AZURE_OPENAI_ENDPOINT environment variable is not set")
        sys.exit(1)
    
    if not os.environ.get("AZURE_OPENAI_API_KEY"):
        logging.error("AZURE_OPENAI_API_KEY environment variable is not set")
        sys.exit(1)

    # Create output directory if it doesn't exist
    os.makedirs(output_dir, exist_ok=True)

    # Ensure input directory exists
    if not os.path.exists(input_dir):
        logging.error(f"Input directory {input_dir} does not exist")
        sys.exit(1)

    # Process all PDFs in input directory
    pdf_files = [f for f in os.listdir(input_dir) if f.lower().endswith('.pdf')]
    
    if not pdf_files:
        logging.warning(f"No PDF files found in {input_dir}")
        sys.exit(0)

    for filename in pdf_files:
        try:
            pdf_path = os.path.join(input_dir, filename)
            
            logging.info(f"Processing PDF: {filename}")
            results = process_pdf(pdf_path)
            
            # Save classification results
            result_path = os.path.join(output_dir, f"{Path(filename).stem}_classification.json")
            with open(result_path, 'w') as f:
                json.dump(results, f, indent=2)
            
            # Print results to console
            logging.info(f"Classification for {filename}:")
            logging.info(json.dumps(results, indent=2))

        except Exception as e:
            logging.error(f"Error processing PDF {filename}: {e}")
            traceback.print_exc()

if __name__ == "__main__":
    main()
