fontconvert.py

import os
import cv2
import numpy as np
from PIL import Image, ImageDraw, ImageFont
import fitz
import logging
from pathlib import Path
from io import BytesIO


class FormatConverter:
    """
    Convert various document formats to processable images.
    Pure Python - No external dependencies, no font files needed.
    """
    
    def __init__(self, config, logger=None):
        self.config = config
        self.logger = logger or logging.getLogger("format_converter")
        self.supported_formats = config.get("processing", {}).get("supported_formats", [
            "pdf", "docx", "doc", "jpg", "jpeg", "png", "tif", "tiff", "bmp"
        ])
        
        self.docx_available = False
        try:
            from docx import Document
            self.docx_available = True
            self.logger.info("python-docx available - DOCX/DOC conversion enabled")
        except ImportError:
            self.logger.warning("python-docx not installed - DOCX/DOC files will be skipped")
        
        self.logger.info(f"FormatConverter initialized")
        self.logger.info(f"Supported formats: {self.supported_formats}")
    
    def get_file_extension(self, filename):
        """Get file extension without dot."""
        return Path(filename).suffix.lower().lstrip('.')
    
    def is_supported_format(self, filename):
        """Check if file format is supported."""
        ext = self.get_file_extension(filename)
        
        if ext in ['docx', 'doc'] and not self.docx_available:
            return False
        
        return ext in self.supported_formats
    
    def convert_to_images(self, file_content, filename):
        """
        Convert any supported format to list of images.
        
        Args:
            file_content: File content as bytes
            filename: Original filename (to determine format)
        
        Returns:
            List of tuples: [(page_number, numpy_image), ...]
        """
        ext = self.get_file_extension(filename)
        
        if not self.is_supported_format(filename):
            self.logger.error(f"Unsupported file format: {ext}")
            return []
        
        self.logger.info(f"Converting {ext.upper()} file: {filename}")
        
        try:
            if ext == 'pdf':
                return self._convert_pdf(file_content)
            elif ext in ['docx', 'doc']:
                return self._convert_docx(file_content)
            elif ext in ['jpg', 'jpeg', 'png', 'tif', 'tiff', 'bmp']:
                return self._convert_image(file_content)
            else:
                self.logger.error(f"Format {ext} not implemented")
                return []
        
        except Exception as e:
            self.logger.error(f"Error converting {ext} file: {str(e)}")
            return []
    
    def _convert_pdf(self, pdf_content):
        """Convert PDF to images using PyMuPDF."""
        try:
            doc = fitz.open(stream=pdf_content, filetype="pdf")
            images = []
            zoom_factor = self.config.get("processing", {}).get("zoom_factor", 2.0)
            
            for page_num in range(len(doc)):
                page = doc.load_page(page_num)
                mat = fitz.Matrix(zoom_factor, zoom_factor)
                pix = page.get_pixmap(matrix=mat)
                
                img = np.frombuffer(pix.samples, dtype=np.uint8).reshape(pix.height, pix.width, pix.n)
                
                if pix.n == 4:
                    img = cv2.cvtColor(img, cv2.COLOR_RGBA2BGR)
                elif pix.n == 1:
                    img = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)
                
                images.append((page_num, img))
                self.logger.debug(f"Converted PDF page {page_num + 1}")
            
            doc.close()
            self.logger.info(f"Successfully converted PDF to {len(images)} images")
            return images
        
        except Exception as e:
            self.logger.error(f"Error converting PDF: {str(e)}")
            return []
    
    def _convert_docx(self, docx_content):
        """
        Convert DOCX/DOC to images using python-docx + Pillow.
        No font files needed - uses PIL's default font.
        """
        if not self.docx_available:
            self.logger.error("python-docx not available - cannot convert DOCX/DOC")
            return []
        
        try:
            from docx import Document
            
            doc = Document(BytesIO(docx_content))
            
            full_text = []
            for para in doc.paragraphs:
                text = para.text.strip()
                if text:
                    full_text.append(text)
            
            for table in doc.tables:
                for row in table.rows:
                    row_text = ' | '.join([cell.text.strip() for cell in row.cells])
                    if row_text.strip():
                        full_text.append(row_text)
            
            if not full_text:
                self.logger.warning("Empty DOCX document")
                full_text = ["[Empty Document]"]
            
            pages = self._split_text_into_pages(full_text)
            
            images = []
            for page_num, page_text in enumerate(pages):
                img = self._text_to_image(page_text)
                images.append((page_num, img))
            
            self.logger.info(f"Successfully converted DOCX to {len(images)} images")
            return images
        
        except Exception as e:
            self.logger.error(f"Error converting DOCX: {str(e)}")
            return []
    
    def _split_text_into_pages(self, text_lines, max_lines_per_page=45):
        """Split text into pages."""
        pages = []
        current_page = []
        
        for line in text_lines:
            estimated_lines = max(1, (len(line) + 79) // 80)
            
            if len(current_page) + estimated_lines > max_lines_per_page and current_page:
                pages.append('\n'.join(current_page))
                current_page = []
            
            current_page.append(line)
        
        if current_page:
            pages.append('\n'.join(current_page))
        
        return pages if pages else ["[Empty Page]"]
    
    def _text_to_image(self, text, width=2480, height=3508):
        """
        Convert text to image (A4 size at 300 DPI).
        Uses PIL's default font - NO external font files needed.
        """
        try:
            img = Image.new('RGB', (width, height), color='white')
            draw = ImageDraw.Draw(img)
            
            font = ImageFont.load_default()
            
            margin = 80
            line_height = 20
            y = margin
            max_width = width - (2 * margin)
            char_width = 10
            
            for paragraph in text.split('\n'):
                if not paragraph.strip():
                    y += line_height
                    continue
                
                words = paragraph.split(' ')
                current_line = ''
                
                for word in words:
                    test_line = current_line + word + ' '
                    estimated_width = len(test_line) * char_width
                    
                    if estimated_width < max_width:
                        current_line = test_line
                    else:
                        if current_line:
                            draw.text((margin, y), current_line.strip(), fill='black', font=font)
                            y += line_height
                        current_line = word + ' '
                    
                    if y > height - margin - 100:
                        draw.text((margin, y), "[Content continues...]", fill='gray', font=font)
                        break
                
                if current_line and y < height - margin - 100:
                    draw.text((margin, y), current_line.strip(), fill='black', font=font)
                    y += line_height
                
                y += line_height // 2
            
            img_array = np.array(img)
            img_bgr = cv2.cvtColor(img_array, cv2.COLOR_RGB2BGR)
            
            return img_bgr
        
        except Exception as e:
            self.logger.error(f"Error creating text image: {str(e)}")
            blank = np.ones((height, width, 3), dtype=np.uint8) * 255
            return blank
    
    def _convert_image(self, image_content):
        """Convert image file (JPG, PNG, etc.) to numpy array."""
        try:
            nparr = np.frombuffer(image_content, np.uint8)
            img = cv2.imdecode(nparr, cv2.IMREAD_COLOR)
            
            if img is None:
                raise ValueError("Failed to decode image")
            
            self.logger.info(f"Successfully converted image")
            return [(0, img)]
        
        except Exception as e:
            self.logger.error(f"Error converting image: {str(e)}")
            return []
-------------------------
old
#fontconvert.py

import os
import cv2
import numpy as np
from PIL import Image, ImageDraw, ImageFont
import fitz  # PyMuPDF
import logging
from pathlib import Path
from io import BytesIO


class FormatConverter:
    """
    Convert various document formats to processable images.
    Pure Python - No external dependencies, no font files needed!
    """
    
    def __init__(self, config, logger=None):
        self.config = config
        self.logger = logger or logging.getLogger("format_converter")
        self.supported_formats = config.get("processing", {}).get("supported_formats", [
            "pdf", "docx", "doc", "jpg", "jpeg", "png", "tif", "tiff", "bmp"
        ])
        
        # Check if python-docx is available
        self.docx_available = False
        try:
            from docx import Document
            self.docx_available = True
            self.logger.info("python-docx available - DOCX/DOC conversion enabled")
        except ImportError:
            self.logger.warning("python-docx not installed - DOCX/DOC files will be skipped")
        
        self.logger.info(f"FormatConverter initialized")
        self.logger.info(f"Supported formats: {self.supported_formats}")
    
    def get_file_extension(self, filename):
        """Get file extension without dot."""
        return Path(filename).suffix.lower().lstrip('.')
    
    def is_supported_format(self, filename):
        """Check if file format is supported."""
        ext = self.get_file_extension(filename)
        
        # Check if DOCX/DOC is actually supported
        if ext in ['docx', 'doc'] and not self.docx_available:
            return False
        
        return ext in self.supported_formats
    
    def convert_to_images(self, file_content, filename):
        """
        Convert any supported format to list of images.
        
        Args:
            file_content: File content as bytes
            filename: Original filename (to determine format)
        
        Returns:
            List of tuples: [(page_number, numpy_image), ...]
        """
        ext = self.get_file_extension(filename)
        
        if not self.is_supported_format(filename):
            self.logger.error(f"Unsupported file format: {ext}")
            return []
        
        self.logger.info(f"Converting {ext.upper()} file: {filename}")
        
        try:
            if ext == 'pdf':
                return self._convert_pdf(file_content)
            elif ext in ['docx', 'doc']:
                return self._convert_docx(file_content)
            elif ext in ['jpg', 'jpeg', 'png', 'tif', 'tiff', 'bmp']:
                return self._convert_image(file_content)
            else:
                self.logger.error(f"Format {ext} not implemented")
                return []
        
        except Exception as e:
            self.logger.error(f"Error converting {ext} file: {str(e)}")
            import traceback
            self.logger.debug(traceback.format_exc())
            return []
    
    def _convert_pdf(self, pdf_content):
        """Convert PDF to images using PyMuPDF."""
        try:
            doc = fitz.open(stream=pdf_content, filetype="pdf")
            images = []
            zoom_factor = self.config.get("processing", {}).get("zoom_factor", 2.0)
            
            for page_num in range(len(doc)):
                page = doc.load_page(page_num)
                mat = fitz.Matrix(zoom_factor, zoom_factor)
                pix = page.get_pixmap(matrix=mat)
                
                # Convert to numpy array
                img = np.frombuffer(pix.samples, dtype=np.uint8).reshape(pix.height, pix.width, pix.n)
                
                # Convert to BGR
                if pix.n == 4:  # RGBA
                    img = cv2.cvtColor(img, cv2.COLOR_RGBA2BGR)
                elif pix.n == 1:  # Grayscale
                    img = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)
                
                images.append((page_num, img))
                self.logger.debug(f"Converted PDF page {page_num + 1}")
            
            doc.close()
            self.logger.info(f"Successfully converted PDF to {len(images)} images")
            return images
        
        except Exception as e:
            self.logger.error(f"Error converting PDF: {str(e)}")
            return []
    
    def _convert_docx(self, docx_content):
        """
        Convert DOCX/DOC to images using python-docx + Pillow.
        No font files needed - uses PIL's default font.
        """
        if not self.docx_available:
            self.logger.error("python-docx not available - cannot convert DOCX/DOC")
            return []
        
        try:
            from docx import Document
            
            # Load document
            doc = Document(BytesIO(docx_content))
            
            # Extract all text content
            full_text = []
            for para in doc.paragraphs:
                text = para.text.strip()
                if text:
                    full_text.append(text)
            
            # Also extract text from tables
            for table in doc.tables:
                for row in table.rows:
                    row_text = ' | '.join([cell.text.strip() for cell in row.cells])
                    if row_text.strip():
                        full_text.append(row_text)
            
            # If no content, return blank page
            if not full_text:
                self.logger.warning("Empty DOCX document")
                full_text = ["[Empty Document]"]
            
            # Split into pages (approximate)
            pages = self._split_text_into_pages(full_text)
            
            # Convert each page to image
            images = []
            for page_num, page_text in enumerate(pages):
                img = self._text_to_image(page_text)
                images.append((page_num, img))
            
            self.logger.info(f"Successfully converted DOCX to {len(images)} images")
            return images
        
        except Exception as e:
            self.logger.error(f"Error converting DOCX: {str(e)}")
            import traceback
            self.logger.debug(traceback.format_exc())
            return []
    
    def _split_text_into_pages(self, text_lines, max_lines_per_page=45):
        """Split text into pages."""
        pages = []
        current_page = []
        
        for line in text_lines:
            # Estimate how many display lines this text will take
            # Assuming ~80 characters per line
            estimated_lines = max(1, (len(line) + 79) // 80)
            
            if len(current_page) + estimated_lines > max_lines_per_page and current_page:
                # Start new page
                pages.append('\n'.join(current_page))
                current_page = []
            
            current_page.append(line)
        
        # Add last page
        if current_page:
            pages.append('\n'.join(current_page))
        
        return pages if pages else ["[Empty Page]"]
    
    def _text_to_image(self, text, width=2480, height=3508):
        """
        Convert text to image (A4 size at 300 DPI).
        Uses PIL's default font - NO external font files needed!
        """
        try:
            # Create white background
            img = Image.new('RGB', (width, height), color='white')
            draw = ImageDraw.Draw(img)
            
            # Use PIL's default font (always available)
            # This is a bitmap font that's built into PIL
            font = ImageFont.load_default()
            
            # Settings
            margin = 80
            line_height = 20  # Default font is smaller
            y = margin
            max_width = width - (2 * margin)
            char_width = 10  # Approximate width of default font characters
            
            # Split text into lines and wrap
            for paragraph in text.split('\n'):
                if not paragraph.strip():
                    y += line_height
                    continue
                
                # Word wrapping
                words = paragraph.split(' ')
                current_line = ''
                
                for word in words:
                    test_line = current_line + word + ' '
                    estimated_width = len(test_line) * char_width
                    
                    if estimated_width < max_width:
                        current_line = test_line
                    else:
                        # Draw current line
                        if current_line:
                            draw.text((margin, y), current_line.strip(), fill='black', font=font)
                            y += line_height
                        current_line = word + ' '
                    
                    # Check if page is full
                    if y > height - margin - 100:
                        draw.text((margin, y), "[Content continues...]", fill='gray', font=font)
                        break
                
                # Draw remaining text in line
                if current_line and y < height - margin - 100:
                    draw.text((margin, y), current_line.strip(), fill='black', font=font)
                    y += line_height
                
                # Add paragraph spacing
                y += line_height // 2
            
            # Convert PIL image to OpenCV format (BGR)
            img_array = np.array(img)
            img_bgr = cv2.cvtColor(img_array, cv2.COLOR_RGB2BGR)
            
            return img_bgr
        
        except Exception as e:
            self.logger.error(f"Error creating text image: {str(e)}")
            # Return blank white image
            blank = np.ones((height, width, 3), dtype=np.uint8) * 255
            return blank
    
    def _convert_image(self, image_content):
        """Convert image file (JPG, PNG, etc.) to numpy array."""
        try:
            # Decode image from bytes using OpenCV
            nparr = np.frombuffer(image_content, np.uint8)
            img = cv2.imdecode(nparr, cv2.IMREAD_COLOR)
            
            if img is None:
                raise ValueError("Failed to decode image")
            
            self.logger.info(f"Successfully converted image")
            return [(0, img)]
        
        except Exception as e:
            self.logger.error(f"Error converting image: {str(e)}")
            return []

-----------------------------------
#config.json

{
  "processing": {
    "batch_size": 10,
    "confidence_threshold": 80,
    "zoom_factor": 2.0,
    "timeout_seconds": 300,
    "supported_formats": ["pdf", "docx", "doc", "jpg", "jpeg", "png", "tif", "tiff", "bmp"],
    "document_types": {
      "invoice": {
        "extraction_fields": ["invoice_number", "total_amount", "date", "vendor"],
        "prompt_module": "invoice_prompt",
        "preprocessing_enabled": true
      }
    }
  }
}

----------------------------------------
#pdfprocessor class
# Add this import at the top
from format_converter import FormatConverter
import base64
import cv2

class PDFProcessor:
    def __init__(self, config, logger, doc_type=None, extraction_fields=None, preprocessing_config=None):
        self.config = config
        self.logger = logger
        self.doc_type = doc_type or "invoice"
        self.extraction_fields = extraction_fields or []
        
        # Initialize format converter
        self.format_converter = FormatConverter(config, logger)
        
        # Initialize preprocessor if configuration provided
        self.preprocessor = None
        if preprocessing_config:
            from preprocessing_utils import ImagePreprocessor
            self.preprocessor = ImagePreprocessor(preprocessing_config, logger)
            self.logger.info(f"Image preprocessing enabled for {self.doc_type}")
        
        self.logger.info(f"PDFProcessor initialized for document type: {self.doc_type}")
    
    def extract_pages_from_file(self, file_content, filename):
        """
        Extract pages from any supported file format.
        Works with: PDF, DOCX, DOC, JPG, PNG, TIFF, BMP
        """
        try:
            # Convert file to images
            images = self.format_converter.convert_to_images(file_content, filename)
            
            if not images:
                self.logger.error(f"No images extracted from {filename}")
                return []
            
            pages = []
            for page_num, img in images:
                try:
                    # Apply preprocessing if enabled
                    if self.preprocessor:
                        self.logger.debug(f"Preprocessing page {page_num + 1}")
                        img = self.preprocessor.process_image(img)
                    
                    # Convert to PNG bytes
                    _, buffer = cv2.imencode('.png', img)
                    img_bytes = buffer.tobytes()
                    
                    # Encode to base64
                    base64_string = base64.b64encode(img_bytes).decode('utf-8')
                    
                    pages.append((page_num, base64_string))
                    self.logger.debug(f"Processed page {page_num + 1}")
                
                except Exception as e:
                    self.logger.error(f"Error processing page {page_num + 1}: {str(e)}")
                    continue
            
            self.logger.info(f"Extracted {len(pages)} pages from {filename}")
            return pages
            
        except Exception as e:
            self.logger.error(f"Error extracting pages: {str(e)}")
            return []
    
    # Keep old method for backward compatibility
    def extract_pdf_pages(self, pdf_content):
        """Legacy method - redirects to new method."""
        return self.extract_pages_from_file(pdf_content, "document.pdf")
    
    # ... rest of your existing PDFProcessor methods ...

    -----------------------------
    #Azurestroragehelper.listblob

    def list_blobs_in_folder(self, folder_path, supported_formats=None):
    """List all supported document blobs in a specific folder."""
    try:
        if supported_formats is None:
            supported_formats = ['pdf']
        
        container_client = self.blob_service_client.get_container_client(self.input_container)
        blob_list = []
        
        for blob in container_client.list_blobs(name_starts_with=folder_path):
            # Get file extension
            ext = blob.name.lower().split('.')[-1]
            if ext in supported_formats:
                blob_list.append(blob.name)
        
        self.logger.info(f"Found {len(blob_list)} supported files in folder: {folder_path}")
        return blob_list
    except Exception as e:
        self.logger.error(f"Error listing blobs: {str(e)}")
        return []

        ------------------------------------
        ###Azure pdf funciton

        # Near the top of the function, after getting extraction_fields
# Add this line:
supported_formats = config["processing"].get("supported_formats", ["pdf"])

# Update the blob listing line:
logger.info(f"Listing files in Azure folder: {azure_folder}")
logger.info(f"Supported formats: {', '.join(supported_formats)}")
document_blobs = storage_helper.list_blobs_in_folder(azure_folder, supported_formats)

# Update the loop variable name from pdf_blobs to document_blobs
for i, blob_name in enumerate(document_blobs):
    try:
        filename = blob_name.split('/')[-1]
        logger.info(f"Processing file {i+1}/{len(document_blobs)}: {filename}")
        
        # ... download blob_content ...
        
        # Apply overlay only to PDFs
        processed_content = blob_content
        if overlay_processor and filename.lower().endswith('.pdf'):
            logger.info(f"Applying overlay to PDF: {filename}")
            processed_content = overlay_processor.process_pdf_with_overlay(blob_content, overlay_config)
        
        # Extract pages from ANY format (PDF, DOCX, images)
        logger.info(f"Extracting pages from {filename}")
        pages = pdf_processor.extract_pages_from_file(processed_content, filename)
        
        # ... rest of your processing code ...

        ------------------------

        
