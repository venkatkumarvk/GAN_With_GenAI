def generate_sql_for_row(self, mapping, row_number=None):
    """
    Generate SQL statements per row with row number comments.
    Only one block per schema mapping to avoid double counting.
    """
    edl = mapping.get("EDL", {})
    rdmof = mapping.get("RDMOF", {})
    original = mapping.get("Original_SSR", {})

    edl_na = edl.get("has_na", True)
    rdmof_na = rdmof.get("has_na", True)
    original_na = original.get("has_na", True)

    sql_statements = []

    # Build the block comment
    row_comment = f"-- Row {row_number} mapping: " if row_number is not None else "-- Row mapping: "

    # 1️⃣ All present → Original→EDL + EDL→RDMOF
    if not original_na and not edl_na and not rdmof_na:
        sql_statements.append(
            f"{row_comment}Original → EDL\n{self.build_sql(original, edl, description='Original → EDL')}"
            f"{row_comment}EDL → RDMOF\n{self.build_sql(edl, rdmof, description='EDL → RDMOF')}"
        )

    # 2️⃣ Original→RDMOF (EDL NA)
    elif not original_na and edl_na and not rdmof_na:
        sql_statements.append(
            f"{row_comment}Original → RDMOF (EDL NA)\n{self.build_sql(original, rdmof, description='Original → RDMOF')}"
        )

    # 3️⃣ Original→EDL (RDMOF NA)
    elif not original_na and not edl_na and rdmof_na:
        sql_statements.append(
            f"{row_comment}Original → EDL (RDMOF NA)\n{self.build_sql(original, edl, description='Original → EDL')}"
        )

    # 4️⃣ EDL→RDMOF (Original NA)
    elif original_na and not edl_na and not rdmof_na:
        sql_statements.append(
            f"{row_comment}EDL → RDMOF (Original NA)\n{self.build_sql(edl, rdmof, description='EDL → RDMOF')}"
        )

    # 5️⃣ Anything else → placeholder
    else:
        sql_statements.append(
            f"{row_comment}Skipped due to multiple NA values\n{self.build_commented_placeholder(mapping, 'Multiple categories have NA values')}"
        )

    return sql_statements
