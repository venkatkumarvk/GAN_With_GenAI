# Your existing code up to the filtering part...

if st.session_state.csv_df is not None:
    filtered_columns = [
        col for col in st.session_state.csv_df.columns
        if not any(col.endswith(suffix) for suffix in exclude_suffixes)
    ]
    filtered_df = st.session_state.csv_df[filtered_columns]
    
    # Initialize "Old Values" ONLY when file is first loaded or when file changes
    # You could also use uploaded file name/size for detection
    current_file_id = f"{len(filtered_df)}_{len(filtered_df.columns)}_{str(filtered_df.columns.tolist())}"
    
    if ("old_values" not in st.session_state or 
        "current_file_id" not in st.session_state or 
        st.session_state.get("current_file_id") != current_file_id):
        
        # Store the original values (first time file is loaded)
        st.session_state.old_values = filtered_df.iloc[0].copy()
        # Store file identifier to detect file changes
        st.session_state.current_file_id = current_file_id
        print(f"New file detected - storing original values: {st.session_state.old_values.to_dict()}")
    
    # Create the "Field", "Old Values", and "New Values" table
    table_format = pd.DataFrame({
        "Field": filtered_df.columns,
        "Old Values": st.session_state.old_values,  # Always use the original values
        "New Values": filtered_df.iloc[0],  # Current values (which may have been updated)
    })
    
    # Convert the "Old Values" and "New Values" columns to strings to avoid type conflicts
    table_format["Old Values"] = table_format["Old Values"].astype(str)
    table_format["New Values"] = table_format["New Values"].astype(str)
    
    # Display the table in Streamlit
    st.dataframe(table_format, use_container_width=True, hide_index=True)
