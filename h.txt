def create_blob_format_csv(all_pdf_results):
    """
    Create CSV data in the same format as what's stored in Azure Blob Storage.
    """
    all_csv_data = []
    
    for pdf_result in all_pdf_results:
        filename = pdf_result["filename"]
        
        # Create rows for this PDF
        pdf_rows = []
        for page in pdf_result["pages"]:
            page_num = page["page"]
            data = page["data"]
            extraction_timestamp = page.get("extraction_timestamp", datetime.now().strftime("%Y-%m-%d %H:%M:%S"))
            
            # Check for errors
            if "error" in data:
                row_data = {"Page": page_num, "Extraction_Timestamp": extraction_timestamp}
                for field in ["VendorName", "InvoiceNumber", "InvoiceDate", "CustomerName", 
                            "PurchaseOrder", "StockCode", "UnitPrice", "InvoiceAmount", 
                            "Freight", "Salestax", "Total"]:
                    row_data[field] = "N/A"
                    row_data[f"{field} Confidence"] = 0
                
                # Add edit tracking columns
                row_data["Manually_Edited_Fields"] = ""
                row_data["Edit_Timestamp"] = ""
                row_data["Original_Values"] = ""
                row_data["Manual_Edit"] = "N"
                
                pdf_rows.append(row_data)
                continue
            
            # Initialize row data
            row_data = {"Page": page_num, "Extraction_Timestamp": extraction_timestamp}
            
            # Process each field
            for field in ["VendorName", "InvoiceNumber", "InvoiceDate", "CustomerName", 
                          "PurchaseOrder", "StockCode", "UnitPrice", "InvoiceAmount", 
                          "Freight", "Salestax", "Total"]:
                field_data = data.get(field, {})
                
                if isinstance(field_data, dict):
                    value = field_data.get("value", "N/A")
                    confidence = field_data.get("confidence", 0)
                else:
                    value = field_data if field_data else "N/A"
                    confidence = 0
                
                # Add to row data
                row_data[field] = value
                row_data[f"{field} Confidence"] = round(confidence * 100, 2)
            
            # Add edit tracking columns
            edited_fields_with_values = []
            latest_edit_timestamp = ""
            original_values = []
            has_manual_edits = False
            
            # Check manual edit tracking info
            if ('manual_edit_tracking' in st.session_state and 
                filename in st.session_state.manual_edit_tracking and 
                str(page_num) in st.session_state.manual_edit_tracking[filename]):
                
                # Get the edit tracking info for this page
                edit_info = st.session_state.manual_edit_tracking[filename][str(page_num)]
                
                # Get the most recent edit timestamp
                timestamps = []
                
                for field, info in edit_info.items():
                    if info.get("edited", False):
                        has_manual_edits = True
                        
                        # Get the current (edited) value for this field
                        current_value = row_data.get(field, "N/A")
                        # Add field name and its value
                        edited_fields_with_values.append(f"{field}: {current_value}")
                        
                        # Add timestamp to list (for finding the most recent)
                        if "edit_timestamp" in info:
                            timestamps.append(info["edit_timestamp"])
                        
                        original_values.append(f"{field}: {info.get('previous_value', 'N/A')}")
                
                # Use the most recent timestamp for Edit_Timestamp
                if timestamps:
                    latest_edit_timestamp = max(timestamps)
            
            row_data["Manually_Edited_Fields"] = "; ".join(edited_fields_with_values) if edited_fields_with_values else ""
            row_data["Edit_Timestamp"] = latest_edit_timestamp
            row_data["Original_Values"] = "; ".join(original_values) if original_values else ""
            row_data["Manual_Edit"] = "Y" if has_manual_edits else "N"
            
            # Add completed row to rows
            pdf_rows.append(row_data)
        
        # Create DataFrame for this PDF
        if pdf_rows:
            # Add to the list of all CSV data
            all_csv_data.append({
                "filename": filename,
                "dataframe": pd.DataFrame(pdf_rows, dtype=str)
            })
    
    return all_csv_data


#download
# In the Download Options tab
with col4:  # Add another column or use an existing one
    # Prepare per-PDF CSV files (like blob storage format)
    if st.button("Prepare Individual PDF CSVs", on_click=reset_download_state):
        with st.spinner("Preparing individual CSV files..."):
            try:
                # Generate CSV data in the same format as blob storage
                pdf_csv_data = create_blob_format_csv(all_pdf_results)
                
                if pdf_csv_data:
                    # Create a zip file with individual CSVs
                    zip_buffer = io.BytesIO()
                    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                    
                    with zipfile.ZipFile(zip_buffer, 'a', zipfile.ZIP_DEFLATED, False) as zip_file:
                        for pdf_data in pdf_csv_data:
                            filename = pdf_data["filename"]
                            base_filename = os.path.splitext(filename)[0]
                            df = pdf_data["dataframe"]
                            
                            # Convert to CSV
                            csv_data = df.to_csv(index=False)
                            
                            # Add to zip
                            zip_file.writestr(f"{base_filename}_{timestamp}.csv", csv_data)
                    
                    # Seek to beginning
                    zip_buffer.seek(0)
                    
                    # Store in session state
                    st.session_state.individual_csvs_zip = zip_buffer
                    st.session_state.download_completed = True
                else:
                    st.warning("No data available to create CSV files")
            except Exception as e:
                st.error(f"Error creating individual CSV files: {e}")
    
    # Show download button when data is ready
    if 'individual_csvs_zip' in st.session_state and st.session_state.download_completed:
        st.download_button(
            label="Download Individual PDF CSVs",
            data=st.session_state.individual_csvs_zip,
            file_name=f"individual_pdf_csvs_{timestamp}.zip",
            mime="application/zip",
            on_click=reset_download_state
        )
