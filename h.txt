import json
import re
from azure.identity import DefaultAzureCredential
from azure.keyvault.secrets import SecretClient
import logging

def load_config(config_path: str, keyvault_url: str = None, logger=None) -> dict:
    """
    Load config.json and resolve @azureKeyVault(secret-name) placeholders using Azure Key Vault.
    
    Args:
        config_path: Path to the config.json file
        keyvault_url: Azure Key Vault URL (optional, only needed if config has Key Vault references)
        logger: Logger instance (optional)
    
    Returns:
        dict: Resolved configuration dictionary
    """
    
    if logger is None:
        logger = logging.getLogger(__name__)
    
    try:
        # Load the raw config with references
        with open(config_path, "r") as f:
            config_data = json.load(f)
        
        logger.info(f"Loaded config from: {config_path}")
        
        # Check if config contains Key Vault references
        config_str = json.dumps(config_data)
        has_keyvault_refs = "@azureKeyVault(" in config_str
        
        if not has_keyvault_refs:
            logger.info("No Key Vault references found in config")
            return config_data
        
        if not keyvault_url:
            raise ValueError("Config contains Key Vault references but keyvault_url not provided")
        
        # Initialize Key Vault client
        logger.info(f"Initializing Key Vault client for: {keyvault_url}")
        credential = DefaultAzureCredential()
        secret_client = SecretClient(vault_url=keyvault_url, credential=credential)
        
        # Keep track of resolved secrets for logging
        resolved_secrets = set()
        
        # Recursive resolver
        def resolve(item):
            if isinstance(item, dict):
                return {k: resolve(v) for k, v in item.items()}
            elif isinstance(item, list):
                return [resolve(i) for i in item]
            elif isinstance(item, str) and item.startswith("@azureKeyVault("):
                # Extract secret name using regex
                matches = re.findall(r"@azureKeyVault\((.*?)\)", item)
                if not matches:
                    logger.warning(f"Invalid Key Vault reference format: {item}")
                    return item
                
                secret_name = matches[0].strip()
                
                try:
                    secret_value = secret_client.get_secret(secret_name).value
                    resolved_secrets.add(secret_name)
                    logger.debug(f"Resolved secret: {secret_name}")
                    return secret_value
                except Exception as e:
                    logger.error(f"Failed to resolve secret '{secret_name}': {str(e)}")
                    raise
            else:
                return item
        
        resolved_config = resolve(config_data)
        
        if resolved_secrets:
            logger.info(f"Successfully resolved {len(resolved_secrets)} Key Vault secrets: {', '.join(resolved_secrets)}")
        
        return resolved_config
    
    except FileNotFoundError:
        logger.error(f"Config file not found: {config_path}")
        raise
    except json.JSONDecodeError as e:
        logger.error(f"Invalid JSON in config file: {str(e)}")
        raise
    except Exception as e:
        logger.error(f"Error loading config: {str(e)}")
        raise


-----
{
  "azure_openai_general": {
    "api_version": "2023-12-01-preview",
    "default": {
      "api_key": "@azureKeyVault(openai-general-default-key)",
      "azure_endpoint": "@azureKeyVault(openai-general-default-endpoint)",
      "deployment_name": "@azureKeyVault(openai-general-default-deployment)",
      "modelname": "gpt-4-vision-preview",
      "api_type": "general"
    },
    "models": {
      "invoice": {
        "api_key": "@azureKeyVault(openai-general-invoice-key)",
        "azure_endpoint": "@azureKeyVault(openai-general-invoice-endpoint)",
        "deployment_name": "@azureKeyVault(openai-general-invoice-deployment)",
        "modelname": "gpt-4-vision-invoice",
        "api_type": "general"
      },
      "eob": {
        "api_key": "@azureKeyVault(openai-general-eob-key)",
        "azure_endpoint": "@azureKeyVault(openai-general-eob-endpoint)",
        "deployment_name": "@azureKeyVault(openai-general-eob-deployment)",
        "modelname": "gpt-4-vision-eob",
        "api_type": "general"
      }
    }
  },
  "azure_openai_batch": {
    "api_version": "2023-12-01-preview",
    "default": {
      "api_key": "@azureKeyVault(openai-batch-default-key)",
      "azure_endpoint": "@azureKeyVault(openai-batch-default-endpoint)",
      "deployment_name": "@azureKeyVault(openai-batch-default-deployment)",
      "modelname": "gpt-4-vision-preview",
      "api_type": "batch"
    },
    "models": {
      "invoice": {
        "api_key": "@azureKeyVault(openai-batch-invoice-key)",
        "azure_endpoint": "@azureKeyVault(openai-batch-invoice-endpoint)",
        "deployment_name": "@azureKeyVault(openai-batch-invoice-deployment)",
        "modelname": "gpt-4-vision-invoice",
        "api_type": "batch"
      }
    }
  },
  "azure_storage": {
    "connection_string": "@azureKeyVault(storage-connection-string)",
    "input_container": "input-pdfs",
    "output_container": "processed-results",
    "input_archive_container": "archived-inputs",
    "high_confidence_folder": "high_confidence/",
    "low_confidence_folder": "low_confidence/"
  },
  "azure_sql": {
    "server": "@azureKeyVault(sql-server)",
    "database": "@azureKeyVault(sql-database)",
    "username": "@azureKeyVault(sql-username)",
    "password": "@azureKeyVault(sql-password)",
    "driver": "ODBC Driver 17 for SQL Server"
  },
  "processing": {
    "batch_size": 10,
    "confidence_threshold": 80,
    "zoom_factor": 2.0,
    "timeout_seconds": 300,
    "document_types": {
      "invoice": {
        "extraction_fields": ["invoice_number", "total_amount", "date", "vendor"],
        "prompt_module": "invoice_prompt"
      },
      "eob": {
        "extraction_fields": ["eob_number", "patient_name", "service_date", "paid_amount", "provider"],
        "prompt_module": "eob_prompt"
      },
      "claim": {
        "extraction_fields": ["claim_number", "patient_id", "diagnosis_code", "procedure_code", "claim_amount"],
        "prompt_module": "claim_prompt"
      }
    }
  },
  "archive": {
    "blob_input_move_on": true,
    "archive_name_format": "archive_{timestamp}.zip",
    "processed_folder": "processed/",
    "unprocessed_folder": "unprocessed/"
  }
}


----
  def main():
    parser = argparse.ArgumentParser(description="Process PDF files using Azure OpenAI with document type support")
    parser.add_argument("--apitype", choices=["general", "batch"], required=True, 
                      help="API type to use (general or batch)")
    parser.add_argument("--source", choices=["azure", "local"], required=True,
                      help="Source location of PDF files (azure or local)")
    parser.add_argument("--folder", required=True, 
                      help="Folder path (in Azure Blob Storage or local filesystem)")
    parser.add_argument("--doctype", choices=["invoice", "eob", "claim"], required=True,
                      help="Document type to process (invoice, eob, or claim)")
    parser.add_argument("--config", default="config.json", 
                      help="Path to configuration file")
    parser.add_argument("--keyvault-url", 
                      help="Azure Key Vault URL (required if config contains Key Vault references)")
    parser.add_argument("--log-level", choices=["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"],
                     default="INFO", help="Set the logging level")
    parser.add_argument("--no-archive", action="store_true",
                     help="Disable archiving regardless of config setting")
    
    args = parser.parse_args()
    
    try:
        # Load configuration with Key Vault support
        config = load_config(args.config, args.keyvault_url)
        
        # Validate document type exists in config
        if args.doctype not in config["processing"]["document_types"]:
            available_types = list(config["processing"]["document_types"].keys())
            raise ValueError(f"Document type '{args.doctype}' not found in config. Available types: {available_types}")
        
        # Override archive setting if --no-archive is specified
        if args.no_archive:
            if "archive" not in config:
                config["archive"] = {}
            config["archive"]["blob_input_move_on"] = False
        
        # Set up logger
        log_level = getattr(logging, args.log_level)
        logger = setup_logger(config, log_level, args.doctype)
        
        logger.info(f"Starting PDF processing with source: {args.source}, folder: {args.folder}, API type: {args.apitype}, document type: {args.doctype}")
        
        # Log Key Vault usage
        if args.keyvault_url:
            logger.info(f"Using Azure Key Vault: {args.keyvault_url}")
        
        # Log archiving configuration
        archive_enabled = config.get("archive", {}).get("blob_input_move_on", False)
        if args.source == "azure":
            logger.info(f"Archiving enabled: {archive_enabled}")
            if archive_enabled:
                archive_container = config["azure_storage"].get("input_archive_container")
                logger.info(f"Archive container: {archive_container}")
        
        # Process PDF files from Azure
        if args.source == "azure":
            process_azure_pdf_files(config, args.apitype, args.folder, args.doctype, logger)
        else:
            logger.error("Local processing with document types not implemented in this example")
            return 1
        
    except Exception as e:
        if 'logger' in locals():
            logger.error(f"Unhandled error: {str(e)}", exc_info=True)
        else:
            print(f"Error: {str(e)}")
        return 1
    
    return 0
