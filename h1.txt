import os
import zipfile
from io import BytesIO
from datetime import datetime
from azure.storage.blob import BlobServiceClient
import logging


class AzureStorageHelper:
    def __init__(self, connection_string, input_container, output_container, 
                 input_archive_container=None, logger=None):
        self.connection_string = connection_string
        self.input_container = input_container
        self.output_container = output_container
        self.input_archive_container = input_archive_container
        self.logger = logger or logging.getLogger("pdf_processor")
        self.blob_service_client = BlobServiceClient.from_connection_string(connection_string)
        
        if self.logger:
            self.logger.info(f"Initialized AzureStorageHelper with containers:")
            self.logger.info(f"  Input: {input_container}")
            self.logger.info(f"  Output: {output_container}")
            self.logger.info(f"  Archive: {input_archive_container}")

    def list_blobs_in_folder(self, folder_path):
        """List all PDF blobs in a specific folder."""
        try:
            container_client = self.blob_service_client.get_container_client(self.input_container)
            blob_list = []
            
            for blob in container_client.list_blobs(name_starts_with=folder_path):
                if blob.name.lower().endswith('.pdf'):
                    blob_list.append(blob.name)
            
            self.logger.info(f"Found {len(blob_list)} PDF files in folder: {folder_path}")
            return blob_list
        except Exception as e:
            self.logger.error(f"Error listing blobs in folder {folder_path}: {str(e)}")
            return []

    def download_blob_to_memory(self, blob_name):
        """Download a blob to memory and return its content."""
        try:
            blob_client = self.blob_service_client.get_blob_client(
                container=self.input_container, 
                blob=blob_name
            )
            content = blob_client.download_blob().readall()
            self.logger.debug(f"Downloaded blob {blob_name} ({len(content)} bytes)")
            return content
        except Exception as e:
            self.logger.error(f"Error downloading blob {blob_name}: {str(e)}")
            return None

    def upload_to_storage(self, blob_name, content, content_type):
        """Upload content to blob storage."""
        try:
            blob_client = self.blob_service_client.get_blob_client(
                container=self.output_container,
                blob=blob_name
            )
            
            if isinstance(content, str):
                content = content.encode('utf-8')
            
            blob_client.upload_blob(content, overwrite=True, content_type=content_type)
            blob_url = blob_client.url
            
            self.logger.debug(f"Uploaded blob: {blob_name}")
            return True, blob_url
        except Exception as e:
            self.logger.error(f"Error uploading blob {blob_name}: {str(e)}")
            return False, None

    def create_archive_zip(self, processed_files, unprocessed_files, archive_config):
        """
        Create a ZIP archive containing processed and unprocessed files.
        
        Args:
            processed_files: List of tuples (blob_name, content) for successfully processed files
            unprocessed_files: List of tuples (blob_name, content) for files with errors
            archive_config: Archive configuration from config
            
        Returns:
            BytesIO object containing the ZIP archive
        """
        try:
            zip_buffer = BytesIO()
            
            with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zipf:
                # Add processed files to processed folder
                processed_folder = archive_config.get('processed_folder', 'processed/')
                for blob_name, content in processed_files:
                    filename = os.path.basename(blob_name)
                    zipf.writestr(f"{processed_folder}{filename}", content)
                    self.logger.debug(f"Added {filename} to processed folder in archive")
                
                # Add unprocessed files to unprocessed folder
                unprocessed_folder = archive_config.get('unprocessed_folder', 'unprocessed/')
                for blob_name, content in unprocessed_files:
                    filename = os.path.basename(blob_name)
                    zipf.writestr(f"{unprocessed_folder}{filename}", content)
                    self.logger.debug(f"Added {filename} to unprocessed folder in archive")
            
            zip_buffer.seek(0)
            self.logger.info(f"Created archive with {len(processed_files)} processed and {len(unprocessed_files)} unprocessed files")
            return zip_buffer
        
        except Exception as e:
            self.logger.error(f"Error creating archive ZIP: {str(e)}")
            return None

    def upload_archive_to_storage(self, archive_content, archive_config):
        """
        Upload the archive ZIP to the archive container.
        
        Args:
            archive_content: BytesIO object containing the ZIP archive
            archive_config: Archive configuration from config
            
        Returns:
            tuple: (success, archive_url)
        """
        try:
            if not self.input_archive_container:
                self.logger.error("Archive container not configured")
                return False, None
            
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            archive_name_format = archive_config.get('archive_name_format', 'archive_{timestamp}.zip')
            archive_name = archive_name_format.format(timestamp=timestamp)
            
            blob_client = self.blob_service_client.get_blob_client(
                container=self.input_archive_container,
                blob=archive_name
            )
            
            blob_client.upload_blob(
                archive_content.getvalue(), 
                overwrite=True, 
                content_type='application/zip'
            )
            
            archive_url = blob_client.url
            self.logger.info(f"Uploaded archive to: {archive_name}")
            return True, archive_url
        
        except Exception as e:
            self.logger.error(f"Error uploading archive: {str(e)}")
            return False, None

    def delete_blob(self, blob_name):
        """Delete a blob from the input container."""
        try:
            blob_client = self.blob_service_client.get_blob_client(
                container=self.input_container,
                blob=blob_name
            )
            blob_client.delete_blob()
            self.logger.debug(f"Deleted blob: {blob_name}")
            return True
        except Exception as e:
            self.logger.error(f"Error deleting blob {blob_name}: {str(e)}")
            return False

    def move_files_to_archive(self, processed_files, unprocessed_files, archive_config):
        """
        Move input files to archive container and delete from input container.
        
        Args:
            processed_files: List of blob names that were successfully processed
            unprocessed_files: List of blob names that had errors
            archive_config: Archive configuration from config
            
        Returns:
            tuple: (success, archive_url)
        """
        try:
            # Download all files for archiving
            processed_file_contents = []
            unprocessed_file_contents = []
            
            # Download processed files
            for blob_name in processed_files:
                content = self.download_blob_to_memory(blob_name)
                if content:
                    processed_file_contents.append((blob_name, content))
            
            # Download unprocessed files
            for blob_name in unprocessed_files:
                content = self.download_blob_to_memory(blob_name)
                if content:
                    unprocessed_file_contents.append((blob_name, content))
            
            # Create archive ZIP
            archive_zip = self.create_archive_zip(
                processed_file_contents, 
                unprocessed_file_contents, 
                archive_config
            )
            
            if not archive_zip:
                return False, None
            
            # Upload archive to storage
            success, archive_url = self.upload_archive_to_storage(archive_zip, archive_config)
            
            if success:
                # Delete original files from input container
                all_files = processed_files + unprocessed_files
                deleted_count = 0
                
                for blob_name in all_files:
                    if self.delete_blob(blob_name):
                        deleted_count += 1
                
                self.logger.info(f"Moved {deleted_count}/{len(all_files)} files to archive")
                return True, archive_url
            
            return False, None
            
        except Exception as e:
            self.logger.error(f"Error moving files to archive: {str(e)}")
            return False, None
